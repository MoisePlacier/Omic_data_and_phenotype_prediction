---
title: "negative_control"
format: html
editor: visual
---

```{r}
library(data.table)
library(caret)
library(ranger)
library(parallel)
library(doParallel)
library(yaml)
library(data.table)
library(ggplot2)
library(caret)
library(nnet)
library(pls)
library(FactoMineR)
library(qqman)
library(mixOmics)
```

```{r}
Pheno_FILE <- "../data/Phenotype.rda"
load(Pheno_FILE)
pheno_all <- as.data.table(Phenotype) 
```

# Negative control using a simulated null phenotype

```{r}
set.seed(2026)

pheno_all[, pheno_null := rnorm(.N, mean = 0, sd = 1)]

hist(pheno_all$pheno_null)
```

# Kinship-aware negative control

On décompose la matrice de kinship (SVD). On génère un signal aléatoire sur chacun de ces axes, proportionnel à son importance, puis on les recombine pour obtenir un phénotype simulé dont la similarité entre individus reflète exactement la structure génétique globale. Un bruit individuel est ensuite ajouté.

Le phénotype pour un individu est donc la somme, sur tous les axes génétiques, de (position génétique de l’individu sur l’axe) × (effet aléatoire de cet axe), plus un bruit individuel.

```{r}
Kinship_FILE <- "../data/Kinship_Poplar.rda"
load(Kinship_FILE)
K <- as.data.table(Kinship_Poplar)
```

## SVD matrice Kinship

```{r}
eig <- eigen(K, symmetric = TRUE)
U <- eig$vectors           
lambda <- eig$values       
## Génération du phénotype 
set.seed(2010)

z <- rnorm(length(lambda), sd=1)  # coefficient aléatoire par composante
g <- U %*% (sqrt(lambda) * z) # Pour chaque individu : somme des loadings individuels multipliés par un effet aléatoire par composante, pondéré par la racine de l’inertie de la composante
```

la covariance de $g$ est exactement $K$. $$ \mathbf{g} \sim \mathcal{N}(\mathbf{0}, \mathbf{K}) $$

```{r}
### Ajout d'un bruit sur les individus

var_g <- var(as.numeric(g))
var_g
h2_target <- 0.5   # Le bruit représente 50 % de variance populationnelle cf R^2 des modèles lm(phenos ~ pop)
```

$$ h^2 = \frac{\sigma_g^2}{\sigma_g^2 + \sigma_e^2} \qquad <=> \qquad\sigma_e^2 = \sigma_g^2 \frac{1 - h^2}{h^2}$$


```{r}
sigma_e2 <- var_g * (1 - h2_target) / h2_target
sigma_e  <- sqrt(sigma_e2)
sigma_e
```

```{r}
e <- rnorm(nrow(K), sd = sigma_e)

pheno_null_pop <- as.numeric(g + e)
pheno_all[, pheno_kin_aware := pheno_null_pop]
```

$$ \mathbf{y} = \mathbf{g} + \epsilon  \qquad <=>\qquad \mathbf{y} \sim \mathcal{N}\bigl(\mathbf{0}, \sigma_g^2 \mathbf{K} + \sigma_e^2 \mathbf{I}\bigr) $$

```{r}
hist(pheno_all$pheno_kin_aware)
```

# Population-aware negative control

Pour un individu $i$ appartenant à la population $j$, le phénotype simulé $Y_{ij}$ est modélisé selon l'équation suivante :

$$Y_{ij} = \beta_{j} + \epsilon_{ij}$$

$*\beta_{j} \sim \mathcal{N}(0, \sigma_{pop}^2)$ $\epsilon_{ij} \sim \mathcal{N}(0, \sigma_{e}^2)$*

```{r}
Loc_FILE <- "../data/localisation.rda"
load(Loc_FILE)
loc_df<- as.data.table(localisation)

pheno_all[, ID := rownames(Phenotype)]

merged<- merge(pheno, loc_df[,list(Population,ID)], by = "ID")

set.seed(2026)

populations <- merged$Population
unique_pop <- unique(populations)

# Variance des effets population
sigma_pop <- 1
sigma_e   <- 1

# Tirage des effets par population
pop_effects <- rnorm(length(unique_pop), mean=0, sd=sigma_pop)
names(pop_effects) <- unique_pop

# Tirage du phénotype par individu et Ajout du phénotype population-aware
pheno_all[, pheno_pop_aware := pop_effects[merged$Population] + rnorm(.N, sd = sigma_e)]

hist(pheno_all$pheno_pop_aware)
plot_df <- data.frame(
  Population = merged$Population,
  Pheno = pheno_all$pheno_pop_aware
)

# Génération du Boxplot
ggplot(plot_df, aes(x = Population, y = Pheno, fill = Population)) +
  geom_boxplot(alpha = 0.7, outlier.color = "red") +
  geom_jitter(width = 0.2, alpha = 0.3) + # Ajout des points individuels pour voir la distribution
  theme_minimal() +
  labs(
    title = "Distribution du Phénotype simulé par Population",
    subtitle = expression(paste("Modèle : ", Y[ij] == beta[j] + epsilon[ij], " (Contrôle Négatif)")),
    x = "Origine Géographique (Population)",
    y = "Valeur du Phénotype simulé"
  ) +
  theme(legend.position = "none")
```

# Pheno déflatés de Kinship et genomic

Pour obtenir des résidus phénotypiques totalement déflatés de la structure génétique, nous avons opté pour une approche hybride : l'utilisation de variables de population et des premières composantes principales (PCs) en effets fixes pour capturer la structure de population globale, complétée par l'inclusion de la matrice de parenté (Kinship) en effet aléatoire pour modéliser l'apparentement plus fin. Cette double correction assure que les résidus fournis à la Random Forest sont exempts de tout signal de structure familiale ou géographique.

### Étapes de génération du phénotype déflaté

-   **Décomposition de la matrice de parenté (Kinship) :** Nous effectuons une décomposition en valeurs propres (EVD) de la matrice $K$ pour obtenir les vecteurs propres utilisés comme composantes principales (PCs). Ces dernières capturent les axes majeurs de la structure génétique :

    $$K = U \Lambda U^T$$

    Où $U$ contient les vecteurs propres et $\Lambda$ les valeurs propres associés.

-   **Intégration des covariables fixes :** Nous sélectionnons les trois premières composantes principales ($PC_1, PC_2, PC_3$) ainsi que l'origine géographique (*Population*) comme effets fixes pour corriger la structure de population globale.

-   **Spécification du modèle linéaire mixte (LMM) :** Pour chaque trait phénotypique, nous ajustons un modèle de type **G-BLUP** (Genomic Best Linear Unbiased Prediction) via l'algorithme `mmer` du package `sommer` : $$y = X\beta + Zu + \epsilon$$

    Où :

    -   $X\beta$ représente les **effets fixes** (Population + 3 PCs).
    -   $Zu$ représente l'**effet aléatoire polygénique**, avec $u \sim \mathcal{N}(0, K\sigma_g^2)$.
    -   $\epsilon$ est l'**erreur résiduelle**, avec $\epsilon \sim \mathcal{N}(0, I\sigma_e^2)$.’

-   **Extraction de la "Matière Noire" (Résidus) :** L'objectif est de récupérer les résidus $\hat{e}$, qui représentent la part de la variation phénotypique non captée par l'additivité et la structure : ’$$\hat{e} = y - (X\hat{\beta} + Z\hat{u})$$

-   **Standardisation et Sauvegarde :** Les résidus sont extraits pour l'ensemble des phénotypes (traits réels et contrôles négatifs). Ils servent de variable cible ($Y$) pour le bras non linéaire (Random Forest).

```{r}
Genomic_FILE <- "../data/Genomic.rda"
load(Genomic_FILE)
geno <- as.data.table(Genomic)
```

```{r}
Kinship_FILE <- "../data/Kinship_Poplar.rda"
load(Kinship_FILE)
K <- as.data.table(Kinship_Poplar)

Loc_FILE <- "../data/localisation.rda"
load(Loc_FILE)
loc_df<- as.data.table(localisation)


Pheno_FILE <- "../data/pheno_null.rds"

pheno_all<- as.data.table(readRDS(Pheno_FILE))
pheno_all[, ID := rownames(Genomic)]
```

## SVD de la matrice SNP



```{r}
variances <- apply(geno, 2, var, na.rm = TRUE)

cols_to_keep <- which(variances > 0 & !is.na(variances))
```


```{r}
geno_filtered <- geno[, ..cols_to_keep]

print(dim(geno_filtered))
```

```{r}
geno_scaled <- scale(geno_filtered) 
dim(geno_scaled)
```

```{r}
res_svd <- svd(geno_scaled)
```


```{r}
U <- res_svd$u %*% diag(res_svd$d)
```

```{r}
dim(U)
```


```{r}
library(sommer)

# On prépare les données : merge phénotypes, localisation (Population) et PCs

pcs_dt <- as.data.table(U[, 1:5])
colnames(pcs_dt) <- paste0("PC", 1:5)
pcs_dt[, ID := pheno_all$ID]
```

```{r}
df_mixed <- merge(pheno_all, loc_df[, .(ID, Population)], by = "ID")
df_mixed <- merge(df_mixed, pcs_dt, by = "ID")

K_matrix <- as.matrix(K)
rownames(K_matrix) <- colnames(K_matrix) <- df_mixed$ID


mod <- mmer(fixed = as.formula(paste("BrAnglVert", "~ Population + PC1 + PC2 + PC3")),
              random = ~ vsr(ID, Gu = K_matrix),
              rcov = ~ units,
              data = df_mixed,
              verbose = FALSE)
```

```{r}
summary(mod)
```


```{r}

# Liste des phénotypes à traiter 
phenos_to_process <- c(
  "CIRC2009","CIRC2011","HT2009","BudFlushSlope",
  "BrAnglVert","Dia2015_sqrt","RamifSyllep",
  "Rust","pheno_pop_aware","pheno_kin_aware","pheno_null","HT2011"
)

# Fonction pour extraire les résidus du modèle mixte (LMM)
get_mixed_residuals <- function(var, data, K_mat) {
  message("Processing: ", var)
  
  # Formule : on retire l'effet fixe de la Pop et des 3 premières PC
  # On ajoute l'effet aléatoire de la Kinship (K)
  
mod <- mmer(fixed = as.formula(paste(var, "~ Population + PC1 + PC2 + PC3")),
              random = ~ vsr(ID, Gu = K_mat),
              rcov = ~ units,
              data = data,
              verbose = FALSE)
  
  # residuals(mod) renvoie les résidus e = y - (Xb + Zu)
  return(as.numeric(residuals(mod)))
}

# Application à tous les phénotypes
K_matrix <- as.matrix(K) # sommer a besoin d'une matrice standard
rownames(K_matrix) <- colnames(K_matrix) <- df_mixed$ID

Y_mixed_residuals <- as.data.frame(
  sapply(phenos_to_process, get_mixed_residuals, data = df_mixed, K_mat = K_matrix)
)

Y_mixed_residuals$ID <- df_mixed$ID

# Sauvegarde
saveRDS(Y_mixed_residuals, "../data/LMM_Residuals_Kinship_Pop.rds")
```
```{r}
get_model_stats_robust <- function(var, data, K_mat) {
  message("Analyse statistique de : ", var)
  
  # Ajustement du modèle
  mod <- mmer(fixed = as.formula(paste(var, "~ Population + PC1 + PC2 + PC3")),
              random = ~ vsr(ID, Gu = K_mat),
              rcov = ~ units,
              data = data,
              verbose = FALSE)
  
  # Extraction des variances (sigma)

  res_vc <- as.data.frame(summary(mod)$varcomp)
  va <- res_vc[grep("ID", rownames(res_vc)), "VarComp"] # Variance additive
  ve <- res_vc[grep("units", rownames(res_vc)), "VarComp"] # Variance résiduelle
  h2 <- va / (va + ve)
  
  #  Extraction des effets fixes et calcul des P-values

  fixed_effects <- mod$Beta
  fixed_effects$SE <- sqrt(diag(mod$VarBeta))
  fixed_effects$t_stat <- fixed_effects$Estimate / fixed_effects$SE
  # Calcul de la p-value (approximation normale pour grands échantillons)
  fixed_effects$p_val <- 2 * (1 - pnorm(abs(fixed_effects$t_stat)))
  
  p_pop <- min(fixed_effects[grep("Population", fixed_effects$Effect), "p_val"], na.rm = TRUE)
  # Idem pour les PCs
  p_pcs <- min(fixed_effects[grep("PC", fixed_effects$Effect), "p_val"], na.rm = TRUE)
  
  return(data.frame(
    Trait = var,
    Var_Additive = round(va, 4),
    Var_Residuelle = round(ve, 4),
    Heritabilite = round(h2, 3),
    P_val_Pop_Min = format.pval(p_pop, digits = 3),
    P_val_PC_Min = format.pval(p_pcs, digits = 3)
  ))
}

# On relance l'application
stats_list <- lapply(phenos_to_process, get_model_stats_robust, data = df_mixed, K_mat = K_matrix)
summary_table <- do.call(rbind, stats_list)

print(summary_table)
```
```{r}
head(summary_table)
```


```{r}
Y_mixed_residuals
```

```{r}
Y_mixed_residuals_merged <- merge(Y_mixed_residuals, loc_df[, .(ID, Population)], by = "ID")
```

## Save

```{r}
saveRDS(pheno_all, file = "../data/pheno_null.rds")
```

# Petit Contrôle avec un LM !

## import des datas

```{r}
Genomic_FILE <- "../data/Genomic.rda"
load(Genomic_FILE)
geno <- as.data.table(Genomic)
```

```{r}
Loc_FILE <- "../data/localisation.rda"
load(Loc_FILE)
loc_df<- as.data.table(localisation)

Pheno_FILE <- "../data/LMM_Residuals_Kinship_Pop.rds"

pheno<- as.data.table(readRDS(Pheno_FILE))



geno[, ID := rownames(Genomic)]
pheno[, ID := rownames(Genomic)]
```

```{r}
pheno
```

```{r}
merged<- merge(pheno_all, loc_df[,list(Population,ID)], by = "ID")

```

```{r}
merged
```

```{r}
merged$Population <- merged$Population.x
```

```{r}
ggplot(merged, aes(x=Population, y = CIRC2009)) +
         geom_boxplot()
merged
```

## LM (Pheno \~ population )

```{r}
df <- as.data.table(merged)

phenos <- names(df)[sapply(df, is.numeric)]
phenos <- setdiff(phenos, c("class_index","Lat","Lgn","ID"))

get_r2 <- function(var) {
  form<- as.formula(paste(var, "~ Population"))
  mod<- lm(form, data = df)
  summary(mod)$r.squared
}

r2_values<- data.table(
  phenotype = phenos,
  r2= sapply(phenos, get_r2))

ggplot(r2_values, aes(x = reorder(phenotype, r2), y = r2)) +
  geom_point(size = 3) +
  geom_segment(aes(x = phenotype, xend = phenotype, y = 0, yend = r2)) +
  coord_flip() +
  ylab("R² lm(Phénotype déflaté ~ Population)") +
  xlab("Caractère phénotypique") +
  theme_minimal()
```

Mince ! Lorsque l'on créé un phénotype avec 50% de variance expliquée par la kinship, le modèle simple LM (phéno kinship \~ Population) à un R\^2 très faible (0.1)... Cela signifie que la corrélation entre les catégories Population et Kinship sont plutot faible finalement ...

## LM pheno ~ PC mat snp

```{r}
library(data.table)
library(ggplot2)

# 1. Préparation des données
df <- as.data.table(merged)
pcs_dt <- as.data.table(U[, 1:3]) # On ne garde que les 3 premières
colnames(pcs_dt) <- paste0("PC", 1:3)
pcs_dt[, ID := pheno_all$ID]

# Fusionner les PC avec le dataframe principal
df <- merge(df, pcs_dt, by = "ID")

# 2. Identification des phénotypes
phenos <- names(df)[sapply(df, is.numeric)]
# On exclut les colonnes de gestion et les nouvelles PC de la liste des phénotypes à tester
phenos <- setdiff(phenos, c("class_index", "Lat", "Lgn", "ID", "PC1", "PC2", "PC3"))

# 3. Fonction de calcul du R²
get_r2 <- function(var) {
  # Formule : Phénotype ~ PC1 + PC2 + PC3
  form <- as.formula(paste(var, "~ PC1 + PC2 + PC3"))
  mod  <- lm(form, data = df)
  return(summary(mod)$r.squared)
}

# 4. Calcul des résultats
r2_values <- data.table(
  phenotype = phenos,
  r2 = sapply(phenos, get_r2)
)

# 5. Visualisation
ggplot(r2_values, aes(x = reorder(phenotype, r2), y = r2)) +
  geom_segment(aes(x = reorder(phenotype, r2), xend = reorder(phenotype, r2), y = 0, yend = r2), color = "grey") +
  geom_point(size = 3, color = "steelblue") +
  coord_flip() +
  labs(
    title = "Part de variance expliquée par la structure (PC1-3)",
    subtitle = "Modèle : Phénotype ~ PC1 + PC2 + PC3",
    y = expression(bold(R^2) ~ "global (Structure)"),
    x = "Caractère phénotypique"
  ) +
  theme_minimal()
```

