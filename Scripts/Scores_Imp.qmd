---
title: "RF_Scores"
format: html
editor: visual
---

```{r}
library(pls)
library(caret)
library(data.table)
library(parallel)
library(doParallel)
library(ranger)
```

```{r}
load_rda_as_dt <- function(file) {
  tmp_env <- new.env()
  load(file, envir = tmp_env)
  obj_name <- ls(tmp_env)[1]           # prend le premier objet
  as.data.table(tmp_env[[obj_name]])
}

# Charger les fichiers
pheno <- load_rda_as_dt("data/LM_Pheno_pop_Residuals.rda")    # Y_FILE peut être un .rda avec n'importe quel nom
geno  <- load_rda_as_dt("data/Genomic.rda")
loc   <- load_rda_as_dt("data/localisation.rda")

# Ajout des ID si nécessaire (adapté aux objets originaux)
if (!"ID" %in% colnames(pheno)) pheno[, ID := rownames(pheno)]
if (!"ID" %in% colnames(geno))  geno[, ID := rownames(geno)]

# Merge avec localisation
merged <- merge(pheno, loc[, .(Population, ID)], by = "ID")
merged <- merge(merged, geno, by = "ID")
```

```{r}
y <- as.numeric(merged[[BASE_NAME]])
X <- as.matrix(merged[, 23:ncol(merged)])
```



```{r}
data(Phenotype)
data(Genomic)
data("localisation")

pheno <- as.data.table(Phenotype)
loc_df <- as.data.table(localisation)
geno <- as.data.table(Genomic)
geno[, ID := rownames(Genomic)]
pheno[, ID := rownames(Phenotype)]
merged <- merge(pheno, loc_df[, list(Population, ID)], by = "ID")
merged <- merge(merged, geno, by = "ID")

# Y : Phénotype, X : Matrice de SNP
y <- merged$CIRC2009
y <- as.numeric(y)
X <- as.matrix(merged[, 23:ncol(merged)])
```

```{r}
run_RF_analysis <- function(task, X, y, save_dir) {

  snp_idx  <- task$snp_idx[[1]]
  test_idx <- task$test_idx[[1]]

  train_idx <- setdiff(seq_len(nrow(X)), test_idx)

  X_train <- X[train_idx, snp_idx, drop = FALSE]
  X_test  <- X[test_idx,  snp_idx, drop = FALSE]

  y_train <- y[train_idx]
  y_test  <- y[test_idx]

  # Random Forest
  p_sub <- ncol(X_train)
  mtry_val <- min(500, p_sub)

  rf_fit <- ranger(
    x = X_train,
    y = y_train,
    num.trees = 500,
    mtry = mtry_val,
    min.node.size = 5,
    importance = "impurity_corrected",
    oob.error = FALSE,
    num.threads = 1,
    seed = 123
  )

  # Prédiction externe

  y_pred <- predict(rf_fit, data = X_test)$predictions

  R2_test   <- cor(y_test, y_pred)^2
  RMSE_test <- sqrt(mean((y_test - y_pred)^2))

  # Importance RF

  rf_imp <- importance(rf_fit)

  imp_dt <- data.table(
    SNP = colnames(X_train),
    importance = as.numeric(rf_imp),
    subset_size = task$subset_size,
    iter = task$iter,
    fold = task$fold
  )

  perf_dt <- data.table(
    subset_size = task$subset_size,
    iter = task$iter,
    fold = task$fold,
    mtry = mtry_val,
    R2_test = R2_test,
    RMSE_test = RMSE_test
  )

  # Sauvegarde

  filename_base <- paste0(
    "_s", task$subset_size,
    "_iter", task$iter,
    "_fold", task$fold,
    ".rds"
  )

  saveRDS(perf_dt, file = file.path(save_dir, paste0("perf_RF", filename_base)))
  saveRDS(imp_dt,  file = file.path(save_dir, paste0("imp_RF",  filename_base)))

  return(NULL)
}

```

```{r}

n_iter <- 400               # Nombre d'itérations de sélection aléatoire de SNP
subset_sizes <- c(5000)  # Tailles des sous-ensembles de SNP à tester
nfold_outer <- 5             # Nombre de folds pour la CV Externe
n_cores <- detectCores() - 2 
SAVE_DIR <- "results_random_RF"
dir.create(SAVE_DIR, showWarnings = FALSE) 
```

```{r}
set.seed(123)
snp_subsets_indices <- lapply(subset_sizes, function(n_snps) {
  replicate(n_iter, sample(ncol(X), n_snps), simplify = FALSE)
})
names(snp_subsets_indices) <- as.character(subset_sizes)


#  Pré-génération des Folds uniques pour CHAQUE itération
set.seed(456)
all_outer_folds <- lapply(1:(n_iter * length(subset_sizes)), function(i) {
  createFolds(y, k = nfold_outer, list = TRUE, returnTrain = FALSE)
})


# Création de la table des tâches
tasks <- data.table(
  subset_size = rep(subset_sizes, each = n_iter * nfold_outer),
  iter = rep(1:n_iter, each = nfold_outer, times = length(subset_sizes)),
  fold = rep(1:nfold_outer, times = n_iter * length(subset_sizes))
)

# Assignation vectorisée des indices de SNP
snp_indices_list <- unlist(snp_subsets_indices, recursive = FALSE)
key_vector_snp <- paste(tasks$subset_size, tasks$iter, sep = "")
tasks[, snp_idx := snp_indices_list[key_vector_snp]]


# Assignation des indices de Test 
tasks[, fold_set_index := .GRP, by = .(subset_size, iter)]
tasks[, test_idx := {
  current_folds <- all_outer_folds[[fold_set_index[1]]]
  list(current_folds[fold])
}, by = .(fold_set_index)]
tasks[, fold_set_index := NULL]
```

```{r}
cl <- makeCluster(n_cores)
registerDoParallel(cl)

results <- foreach(
  i = seq_len(nrow(tasks)),
  .packages = c("ranger", "caret", "data.table"),
  .export = c("X", "y", "run_RF_analysis", "tasks", "SAVE_DIR")
) %dopar% {

  run_RF_analysis(tasks[i], X, y, SAVE_DIR)

}

stopCluster(cl)
```

```{r}
imp_all <- rbindlist(
  lapply(list.files(SAVE_DIR, pattern = "imp_RF", full.names = TRUE), readRDS)
)
```

```{r}
rf_summary <- imp_all[, .(
  mean_imp = mean(abs(importance), na.rm = TRUE),
  sd_imp   = sd(importance, na.rm = TRUE),
  freq     = .N
), by = SNP]
```

```{r}

# Filtrer les Top N SNPs selon la moyenne d'importance RF
N_TOP_SNPS <- 100
topN_SNPs <- rf_summary[order(-abs(mean_imp))][1:N_TOP_SNPS, SNP]

# Sélectionner les observations correspondantes
df_topN_RF <- imp_all[SNP %in% topN_SNPs]

# Tri des SNP pour l'axe x (du plus important au moins important)
df_topN_RF[, SNP := factor(SNP, levels = topN_SNPs)]

# Visualisation : distribution des importances RF
ggplot(df_topN_RF, aes(x = SNP, y = importance)) +
  geom_violin(trim = FALSE, aes(fill = SNP)) +
  geom_boxplot(width = 0.1, outlier.size = 0.5) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  labs(
    x = paste0("Top ", N_TOP_SNPS, " SNPs (triés par importance RF)"),
    y = "Importance RF (par Fold et Itération)",
    title = paste("Distribution de l'importance RF pour les", N_TOP_SNPS, "SNP les plus importants"),
    fill = "SNP"
  ) +
  guides(fill = "none")
```

```{r}
# Sélection des Top N SNPs selon l'importance moyenne absolue
N_TOP_SNPS <- 50
topN_SNPs <- rf_summary[order(-mean_imp)][1:N_TOP_SNPS, SNP]

# Filtrer les observations correspondantes dans imp_all
df_topN_RF <- imp_all[SNP %in% topN_SNPs]

# Transformer en valeurs absolues
df_topN_RF[, importance_abs := abs(importance)]

# Tri des SNP pour l'axe x (du plus important au moins important)
df_topN_RF[, SNP := factor(SNP, levels = topN_SNPs)]

# Boxplot
ggplot(df_topN_RF, aes(x = SNP, y = importance_abs)) +
  geom_boxplot(outlier.size = 0.5, fill = "steelblue") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  labs(
    x = paste0("Top ", N_TOP_SNPS, " SNPs (triés par importance RF)"),
    y = "Importance RF (valeur absolue)",
    title = paste("Distribution de l'importance RF absolue pour les", N_TOP_SNPS, "SNP les plus importants")
  )

```
