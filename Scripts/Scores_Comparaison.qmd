---
title: "Scores_Comparaison"
format: html
editor: visual
---

```{r}
library(pls)
library(caret)
library(data.table)
library(parallel)
library(doParallel)
library(data.table)
library(ggplot2)
library(nnet)
library(pls)
library(FactoMineR)
library(qqman)
library(mixOmics)
library(glmnet)
library(corrplot)
```

## leccture des scores

```{r}
library(arrow)
cols_to_read <- c(
  "SNP", "phenotype", "method", "context", "mean","sd")
all_scores_dt <- read_parquet("Pipelines_scoring_SNP/results/all_scores_merged.parquet",
                              as_data_table = TRUE,
                              col_select = cols_to_read)

# Classement basé sur la moyenne

# colonne 'mean' comme score global pour le ranking
all_scores_dt[, rank := frank(-mean, ties.method = "average"), by = .(phenotype, method, context)]

# 1. Z-score
all_scores_dt[, score_z := (mean - mean(mean, na.rm = TRUE)) / sd(mean, na.rm = TRUE),
              by = .(phenotype, method, context)]

# 2. Min-max scaling sur le z-score pour avoir 0-1
all_scores_dt[, score_scaled := (score_z - min(score_z, na.rm = TRUE)) /
                                  (max(score_z, na.rm = TRUE) - min(score_z, na.rm = TRUE)),
              by = .(phenotype, method)]

all_scores_dt[, method_context := paste(method, context, sep = "_")]
all_scores_dt[, method_context := factor(method_context, levels = unique(method_context))]

tmp <- tstrsplit(all_scores_dt$SNP, "_")
all_scores_dt[, chrom := tmp[[1]]]
all_scores_dt[, pos   := as.numeric(tmp[[2]])]

all_scores_dt[, chrom_num := as.numeric(sub("^Chr", "", chrom))]
```


```{r}
unique(all_scores_dt$phenotype)
```



# TOP K comparaison 

## Phéno x Phéno

```{r}
compare_all_phenos_fast <- function(dt, phenos, method_sel, context_sel, topK = 1000) {

  dt_sub <- dt[
    method == method_sel &
    context == context_sel &
    phenotype %in% phenos &
    !is.na(rank),
    .(phenotype, SNP, rank)
  ]

  setkey(dt_sub, phenotype, rank)

  # TOP-K SNPs par phénotype 
  topK_snps <- dt_sub[
    , head(.SD, topK), by = phenotype
  ][
    , .(SNP = list(SNP)), by = phenotype
  ]

  snp_list <- setNames(topK_snps$SNP, topK_snps$phenotype)

  # Toutes les paires de phénotypes
  pheno_pairs <- CJ(
    pheno1 = phenos,
    pheno2 = phenos,
    unique = FALSE
  )

  # Calcul overlap
  pheno_pairs[
    , topK_overlap := {
      s1 <- snp_list[[pheno1]]
      s2 <- snp_list[[pheno2]]
      if (is.null(s1) || is.null(s2)) {
        NA_real_
      } else {
        length(intersect(s1, s2)) / min(length(s1), length(s2))
      }
    },
    by = .(pheno1, pheno2)
  ]

  pheno_pairs[
    , `:=`(
      method = method_sel,
      context = context_sel
    )
  ]

  pheno_pairs[]
}

```

```{r}
phenos_run <- c(
  "CIRC2009","CIRC2011","HT2009","BudFlushSlope",
  "BrAnglVert","Dia2015_sqrt","RamifSyllep",
  "Rust","pheno_pop_aware","pheno_kin_aware","pheno_null"
)
topK_run = 100
RF_res_pheno <- compare_all_phenos_fast(
  all_scores_dt, phenos_run, "RF", "phenotype", topK = topK_run
)

RF_res_res <- compare_all_phenos_fast(
  all_scores_dt, phenos_run, "RF", "residuals", topK = topK_run
)

VIP_res_pheno <- compare_all_phenos_fast(
  all_scores_dt, phenos_run, "VIP", "phenotype", topK = topK_run
)

VIP_res_res <- compare_all_phenos_fast(
  all_scores_dt, phenos_run, "VIP", "residuals", topK = topK_run
)

farmcpu_run <- compare_all_phenos_fast(
  all_scores_dt,phenos_run,"FarmCPU", "GWAS", topK = topK_run)

mlm_run <- compare_all_phenos_fast(
  all_scores_dt,phenos_run,"MLM", "GWAS", topK = topK_run)

```

```{r}

RF_res_pheno[, context := "RF_phenotype"]
RF_res_res[, context := "RF_residuals"]

VIP_res_pheno[, context := "VIP_phenotype"]
VIP_res_res[, context := "VIP_residuals"]

farmcpu_run[, context := "FarmCPU"]

mlm_run[, context := "MLM"]

# Fusionner les deux résultats pour comparer
res_all <- rbind(RF_res_pheno, RF_res_res,VIP_res_pheno,VIP_res_res,farmcpu_run,mlm_run)
```

```{r}


# Heatmap TOP K overlap
ggplot(res_all, aes(x = pheno1, y = pheno2, fill = topK_overlap)) +
  geom_tile() +
  facet_wrap(~ context) +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
  theme_minimal() +
  labs(
    title = paste0("Proportion TOP ", topK_run, " SNPs communs entre phénotypes"),
    fill = "TOP K overlap"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

## Méthode x méthode 

```{r}
library(data.table)
library(ggplot2)

# --- Liste unique des combinaisons méthode × contexte ---
method_context_list <- unique(all_scores_dt[, .(method, context)])
method_context_list[, method_context := paste(method, context, sep = "_")]

# --- Fonction pour calculer le recouvrement topK entre deux combinaisons pour un phéno ---
topK_overlap_mc <- function(dt, pheno, mc1, mc2, topK = 100) {
  
  # Séparer méthode et contexte
  mc1_split <- strsplit(mc1, "_")[[1]]
  mc2_split <- strsplit(mc2, "_")[[1]]
  
  # Extraire les rangs en évitant le conflit avec la fonction rank()
  dt1 <- dt[phenotype == pheno & method == mc1_split[1] & context == mc1_split[2],
            .(SNP, rank1 = get("rank"))]
  dt1 <- dt1[!is.na(rank1)]
  
  dt2 <- dt[phenotype == pheno & method == mc2_split[1] & context == mc2_split[2],
            .(SNP, rank2 = get("rank"))]
  dt2 <- dt2[!is.na(rank2)]
  
  # Si une des combinaisons est absente
  if(nrow(dt1) == 0 || nrow(dt2) == 0) return(NA_real_)
  
  # Merge sur les SNPs communs
  merged <- merge(dt1, dt2, by = "SNP")
  if(nrow(merged) == 0) return(0)
  
  # TopK overlap
  top1 <- merged[order(rank1)][1:min(topK, .N), SNP]
  top2 <- merged[order(rank2)][1:min(topK, .N), SNP]
  
  length(intersect(top1, top2)) / min(topK, .N)
}

# --- Fonction pour construire la matrice de recouvrement topK pour un phéno ---
make_overlap_matrix <- function(dt, pheno, topK = 100) {
  
  mc_vec <- method_context_list$method_context
  mat <- matrix(NA_real_, nrow = length(mc_vec), ncol = length(mc_vec),
                dimnames = list(mc_vec, mc_vec))
  
  for(i in seq_along(mc_vec)) {
    for(j in seq_along(mc_vec)) {
      mat[i, j] <- topK_overlap_mc(dt, pheno, mc_vec[i], mc_vec[j], topK)
    }
  }
  mat
}
```

```{r}
plot_overlap <- function(overlap_df){
  ggplot(overlap_df, aes(x = Var2, y = Var1, fill = value)) +
  geom_tile() +
  geom_text(aes(label = round(value, 2))) +
  scale_fill_gradient(low = "white", high = "steelblue", na.value = "grey90") +
  labs(title = paste("Top", 1000, "SNP overlap "),
       x = "Méthode × Contexte", y = "Méthode × Contexte") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))}
```


```{r}
pheno_example <- "CIRC2009"
overlap_mat <- make_overlap_matrix(all_scores_dt, pheno_example, topK = 1000)
```

```{r}
overlap_BudFlushSlope <- make_overlap_matrix(all_scores_dt, "BudFlushSlope", topK = 100)
```



```{r}
overlap_mat_null <- make_overlap_matrix(all_scores_dt, "pheno_null", topK = 1000)
overlap_mat_kin <- make_overlap_matrix(all_scores_dt, "pheno_kin_aware", topK = 1000)
overlap_mat_pop <- make_overlap_matrix(all_scores_dt, "pheno_pop_aware", topK = 1000)
```


```{r}
# ggplot pour heatmap

overlap_df <- as.data.table(as.table(overlap_BudFlushSlope))

setnames(overlap_df, c("Var1","Var2","value"))

plot_overlap(overlap_df)

```



# Focus sur 1 chromosome 



```{r}
dt_plot <- all_scores_dt[
  method_context %in% c("RF_residuals","RF_phenotype","VIP_phenotype","VIP_residuals","FarmCPU_GWAS","MLM_GWAS") &
  chrom %in% c("Chr13") &
  rank <200 &
  phenotype %in% c("pheno_null","pheno_kin_aware","pheno_pop_aware","CIRC2009","BudFlushSlope")
]

ggplot(dt_plot, aes(x = pos, y = score_scaled, color = phenotype, alpha = score_scaled)) +
  geom_point(size = 1) +
  facet_grid(method_context ~ chrom, scales = "free_x") +
  coord_cartesian(ylim = c(0,1)) +  # force y entre 0 et 1 sans couper les données
  theme_minimal() +
  labs(
    title = "Scores moyens des SNP du chromosome 10 par phénotype et méthode de scoring",
    x = "Position SNP",
    y = "Score normalisé",
    alpha = "Score"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text.y = element_text(angle = 0)
  )

```


```{r}
library(ggplot2)
library(plotly)

p <- ggplot(
  dt_plot,
  aes(
    x = pos,
    y = score_scaled,
    color = phenotype,
    text = paste0("SNP: ", SNP, "<br>",
                  "Score: ", round(score_scaled,3), "<br>",
                  "Rank: ", rank))  # info affichée au survol
  ) +
  geom_point(size = 2, alpha = 0.7) +
  facet_grid(method_context ~ chrom, scales = "free_x") +
  scale_y_continuous(breaks = c(0,1)) +
  theme_minimal() +
  theme(
    axis.text.x. = element_text(angle = 45, hjust = 1),
    strip.text.y = element_text(angle = 0)
  )

ggplotly(p, tooltip = "text")  # rend le graphique interactif

```


```{r}
library(FactoMineR)
library(factoextra)

# Matrice SNP x Phénotype
snp_mat <- dcast(all_scores_dt[method_context == "RF_residuals"], SNP ~ phenotype, value.var = "mean", fill = 0)
rownames(snp_mat) <- snp_mat$SNP
snp_mat$SNP <- NULL
res.pca <- PCA(snp_mat, graph = FALSE)
chrom_factor <- factor(all_scores_dt$chrom_num[match(rownames(snp_mat), all_scores_dt$SNP)])

fviz_pca_ind(res.pca, 
             geom = "point", 
             col.ind = chrom_factor,  # <- facteur, pas numérique
             palette = "jco", 
             addEllipses = TRUE,
             legend.title = "Chromosome")
```

```{r}
snp_mat <- dcast(all_scores_dt[method_context == "RF_phenotype"], SNP ~ phenotype, value.var = "mean", fill = 0)
rownames(snp_mat) <- snp_mat$SNP
snp_mat$SNP <- NULL
res.pca <- PCA(snp_mat, graph = FALSE)
chrom_factor <- factor(all_scores_dt$chrom_num[match(rownames(snp_mat), all_scores_dt$SNP)])

fviz_pca_ind(res.pca, 
             geom = "point", 
             col.ind = chrom_factor,  # <- facteur, pas numérique
             palette = "jco", 
             legend.title = "Chromosome")

```

```{r}
snp_mat <- dcast(all_scores_dt[method_context == "VIP_residuals"], SNP ~ phenotype, value.var = "score_scaled", fill = 0)
rownames(snp_mat) <- snp_mat$SNP
snp_mat$SNP <- NULL
res.pca <- PCA(snp_mat, graph = FALSE)
chrom_factor <- factor(all_scores_dt$chrom_num[match(rownames(snp_mat), all_scores_dt$SNP)])

fviz_pca_ind(res.pca, 
             geom = "point", 
             col.ind = chrom_factor,  # <- facteur, pas numérique
             palette = "jco", 
             legend.title = "Chromosome")
```

```{r}
# Top 100 SNP pour un phénotype donné
topK <- 100
pheno_sel <- "CIRC2011"

top_snps <- all_scores_dt[phenotype == pheno_sel & method_context == "VIP_residuals", .SD[order(-score_scaled)][1:topK], by=phenotype]$SNP

# Ajouter colonne topK dans la table
all_scores_dt[, is_topK := SNP %in% top_snps]

```

```{r}
top_snps_vec <- rownames(snp_mat) %in% top_snps

# Vérifier
length(top_snps_vec)  # doit être égal à nrow(snp_mat)

# PCA avec top K mis en évidence
fviz_pca_ind(res.pca,
             geom = "point",
             col.ind = ifelse(top_snps_vec, "topK", "other"),
             palette = c("red", "grey"),
             legend.title = "Top SNP")
```


# Scores de duplan 

```{r}
objects <- load("../2_RandomForest_Duplan/rf_results_Genomic.Rdata")
```

```{r}
summary(objects)
```


```{r}
summary(cross_val_results)
```

```{r}

cross_val_results$HT2009

```

```{r}
library(devtools)
if (!require(archivist)){
  install_github("archivist", "pbiecek")
  require(archivist)
  }
library(tools)
```

```{r}
# convert .RData -> .rdb/.rdx
lazyLoad = local({load("../1_Ridge_Duplan/Pred_MultiOmic_OutputORL.RData"); 
                  environment()})
tools:::makeLazyLoadDB(lazyLoad, "Huge")
```

