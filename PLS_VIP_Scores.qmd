---
title: "PLS_VIP_Scores"
format: html
editor: visual
---


# PLS Subset SNP | calcul de VIP | nested CV 


# Fonction pour calculer les VIP 

$$VIP_{j} = \sqrt{ p \frac{\displaystyle \sum_{h=1}^{A} SS_{Y,h}\frac{w_{jh}^{2}}{\lVert w_{h} \rVert^{2}}}{\displaystyle \sum_{h=1}^{A} SS_{Y,h}} }$$

```{r}
library(pls)
library(caret)
library(data.table)
library(parallel)
library(doParallel)

data(Phenotype)
data(Genomic)
data("localisation")

pheno <- as.data.table(Phenotype)
loc_df <- as.data.table(localisation)
geno <- as.data.table(Genomic)
geno[, ID := rownames(Genomic)]
pheno[, ID := rownames(Phenotype)]
merged <- merge(pheno, loc_df[, list(Population, ID)], by = "ID")
merged <- merge(merged, geno, by = "ID")

# Y : Phénotype, X : Matrice de SNP
y <- merged$CIRC2009
y <- as.numeric(y)
X <- as.matrix(merged[, 23:ncol(merged)])
```


```{r}
calc_vip <- function(pls_model) {
  W <- pls_model$loading.weights
  SSY <- colSums(pls_model$Yscores^2)
  p <- nrow(W)
  vip <- numeric(p)
  for (j in 1:p) {
    vip[j] <- sqrt(p * sum(SSY * (W[j, ]^2)) / sum(SSY))
  }
  names(vip) <- rownames(W)
  return(vip)
}
```





```{r}
run_pls_analysis <- function(task, X, y, save_dir) {

  snp_idx <- task$snp_idx[[1]]
  test_idx <- task$test_idx[[1]]
  
  X_sub <- X[, snp_idx, drop = FALSE]
  
  train_idx <- setdiff(seq_len(nrow(X_sub)), test_idx)
  
  X_train_df <- as.data.frame(X_sub[train_idx, , drop = FALSE])
  y_train <- y[train_idx]
  X_test_df <- as.data.frame(X_sub[test_idx, , drop = FALSE])
  y_test <- y[test_idx]

  names(X_train_df) <- make.names(names(X_train_df))
  names(X_test_df) <- make.names(names(X_test_df))
  

  inner_train_index <- createDataPartition(y_train, p = 0.9, list = FALSE)
  inner_X_train <- X_train_df[inner_train_index, , drop = FALSE]
  inner_y_train <- y_train[inner_train_index]
  inner_X_test <- X_train_df[-inner_train_index, , drop = FALSE]
  inner_y_test <- y_train[-inner_train_index]
  
  df_inner_train <- data.frame(y = inner_y_train, inner_X_train)
  
  # Entraîner et comparer ncomp=2 et ncomp=3
  PLS2 <- plsr(y ~ ., data = df_inner_train, ncomp = 2, validation = "none")
  PLS3 <- plsr(y ~ ., data = df_inner_train, ncomp = 3, validation = "none")
  
  y_pred2 <- as.vector(predict(PLS2, newdata = inner_X_test, ncomp = 2))
  y_pred3 <- as.vector(predict(PLS3, newdata = inner_X_test, ncomp = 3))
  
  RMSE_inner_test_2 <- sqrt(mean((inner_y_test - y_pred2)^2))
  RMSE_inner_test_3 <- sqrt(mean((inner_y_test - y_pred3)^2))
  
  ncomp_opt <- ifelse(RMSE_inner_test_2 < RMSE_inner_test_3, 2, 3)
  
  # Modèle Final
  
  df_train <- data.frame(y = y_train, X_train_df)
  pls_final <- plsr(y ~ ., data = df_train, ncomp = ncomp_opt, validation = "none")
  
  # Évaluation Externe 
  
  y_pred_final <- as.vector(predict(pls_final, newdata = X_test_df, ncomp = ncomp_opt))
  R2_test <- cor(y_test, y_pred_final)^2
  RMSE_test <- sqrt(mean((y_test - y_pred_final)^2))
  
  # VIP
  vip_res <- calc_vip(pls_final)
  
  # Sauvegarde des résultats
  perf_dt <- data.table(
    subset_size = task$subset_size, iter = task$iter, fold = task$fold,
    ncomp_opt = ncomp_opt, R2_test = R2_test, RMSE_test = RMSE_test
  )
  vip_dt <- data.table(
    SNP = names(vip_res), VIP = as.numeric(vip_res),
    subset_size = task$subset_size, iter = task$iter, fold = task$fold
  )
  
  filename_base <- paste0("_s", task$subset_size, "_iter", task$iter, "_fold", task$fold, ".rds")
  saveRDS(perf_dt, file = paste0(save_dir, "/perf", filename_base))
  saveRDS(vip_dt, file = paste0(save_dir, "/vip", filename_base))
  
  return(NULL) 
}
```


```{r}

n_iter <- 400                # Nombre d'itérations de sélection aléatoire de SNP
subset_sizes <- c(5000)  # Tailles des sous-ensembles de SNP à tester
nfold_outer <- 5             # Nombre de folds pour la CV Externe
n_cores <- detectCores() - 2 
SAVE_DIR <- "results_random_VIP_PLS"
dir.create(SAVE_DIR, showWarnings = FALSE) 
```


```{r}

set.seed(123)
snp_subsets_indices <- lapply(subset_sizes, function(n_snps) {
  replicate(n_iter, sample(ncol(X), n_snps), simplify = FALSE)
})
names(snp_subsets_indices) <- as.character(subset_sizes)


# 2.2. Pré-génération des Folds pour CHAQUE itération
set.seed(456)
all_outer_folds <- lapply(1:(n_iter * length(subset_sizes)), function(i) {
  createFolds(y, k = nfold_outer, list = TRUE, returnTrain = FALSE)
})


# 2.3. Création de la table des tâches
tasks <- data.table(
  subset_size = rep(subset_sizes, each = n_iter * nfold_outer),
  iter = rep(1:n_iter, each = nfold_outer, times = length(subset_sizes)),
  fold = rep(1:nfold_outer, times = n_iter * length(subset_sizes))
)

# 2.4. Assignation vectorisée des indices de SNP
snp_indices_list <- unlist(snp_subsets_indices, recursive = FALSE)
key_vector_snp <- paste(tasks$subset_size, tasks$iter, sep = "")
tasks[, snp_idx := snp_indices_list[key_vector_snp]]


# 2.5. Assignation des indices de Test 
tasks[, fold_set_index := .GRP, by = .(subset_size, iter)]
tasks[, test_idx := {
  current_folds <- all_outer_folds[[fold_set_index[1]]]
  list(current_folds[fold])
}, by = .(fold_set_index)]
tasks[, fold_set_index := NULL] 


cl <- makeCluster(n_cores)
registerDoParallel(cl)

results <- foreach(
  i = seq_len(nrow(tasks)), 
  .packages = c("pls", "caret", "data.table"), 
  .export = c("X", "y", "calc_vip", "run_pls_analysis", "tasks")
) %dopar% {
  
  run_pls_analysis(tasks[i], X, y, SAVE_DIR)
}

stopCluster(cl)
```

```{r}
SAVE_DIR <- "results_random_VIP_PLS"
# tous fichiers de performance 
perf_files <- list.files(path = SAVE_DIR, pattern = "^perf_s5000.*\\.rds$", full.names = TRUE)
results_perf <- rbindlist(lapply(perf_files, readRDS))

# tous les fichiers VIP 
vip_files <- list.files(path = SAVE_DIR, pattern = "^vip_s5000.*\\.rds$", full.names = TRUE)
results_vip <- rbindlist(lapply(vip_files, readRDS))

```

```{r}
N_ITER_TOTAL <- results_perf[, max(iter)] * length(unique(results_perf$subset_size))
# Nombre total d'apparitions (pour 5 iters de 100 et 5 iters de 500)

vip_stability <- results_vip[, .(VIP_mean = mean(VIP, na.rm = TRUE),
                                 VIP_sd = sd(VIP, na.rm = TRUE),
                                 N_Observations = .N),
                             by = SNP]

# Le nombre max d'observations pour un SNP est :
# N_Folds (5) * N_Iterations (5) * N_Taille_Subsets (2) = 50 observations max

# Étude de la variabilité : VIP moyen vs Écart-type du VIP
ggplot(vip_stability, aes(x = VIP_mean, y = VIP_sd, size = N_Observations)) +
  geom_point(alpha = 0.6) +
  geom_text(data = vip_stability[order(-VIP_mean)][1:5], 
            aes(label = SNP), vjust = -1, color = "red") +
  labs(title = "Stabilité du Score VIP : Moyenne vs Écart-Type",
       x = "VIP Moyen (Robustesse)",
       y = "Écart-type du VIP (Stabilité)",
       size = "Fréquence d'Observation") +
  theme_minimal()
```


```{r}
vip_mean <- results_vip[, .(VIP_mean = mean(VIP, na.rm = TRUE), 
                            SNP_count = .N,
                            SNP_max_size = max(subset_size)), 
                        by = SNP]


N_TOP_SNPS <- 50 
# Correction de l'indexation : utiliser [1:N_TOP_SNPS, SNP] au lieu de [0:5000, SNP]
topN_SNPs <- vip_mean[order(-VIP_mean)][1:N_TOP_SNPS, SNP]

df_topNPLS <- results_vip[SNP %in% topN_SNPs]

# Ajout de l'information VIP_mean pour le tri de l'axe X dans ggplot
df_topNPLS <- merge(df_topNPLS, vip_mean[, .(SNP, VIP_mean)], by = "SNP")

# 2.3. Visualisation de la distribution du VIP pour les Top N SNP
ggplot(df_topNPLS, aes(x = reorder(SNP, VIP_mean), y = VIP)) +
  geom_violin(trim = FALSE, aes(fill = SNP)) +
  geom_boxplot(width = 0.1, outlier.size = 0.5) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
  ) +
  labs(
    x = "SNP (Trié par VIP moyen)",
    y = "Score VIP (par Fold et Itération)",
    title = paste("Distribution du VIP pour les", N_TOP_SNPS, "SNP les plus importants"),
    fill = "SNP"
  ) +
  guides(fill = "none")
```
```{r}
perf_by_size <- results_perf[, .(R2_mean = mean(R2_test, na.rm = TRUE),
                                 R2_sd = sd(R2_test, na.rm = TRUE)), 
                             by = subset_size]

print(perf_by_size)

# Visualisation par taille de subset
ggplot(results_perf, aes(x = factor(subset_size), y = R2_test, fill = factor(subset_size))) +
  geom_boxplot() +
  labs(title = expression("Performance R² par Taille de Sous-Ensemble de SNP"),
       x = "Taille du Sous-Ensemble de SNP",
       y = expression(R^2~"(Test Externe)"),
       fill = "Taille") +
  theme_minimal()
```
```{r}
library(data.table)

snp_names <- colnames(X) 

coords <- do.call(rbind, strsplit(colnames(geno), "_"))
chrom <- as.factor(coords[, 1])
pos <- as.numeric(coords[, 2])

# Création de la table de localisation
snp_localisation <- data.table(
  SNP = colnames(geno),
  Chromosome = chrom,
  Position = pos
)
snp_localisation <- snp_localisation[!is.na(Position)] 

# Calcul du VIP moyen par SNP
vip_stability <- results_vip[, .(VIP_mean = mean(VIP, na.rm = TRUE),
                                 VIP_sd = sd(VIP, na.rm = TRUE),
                                 N_Observations = .N),
                             by = SNP]

# Jointure avec les coordonnées
vip_loc <- merge(vip_stability, snp_localisation, by = "SNP", all.x = TRUE)

print("Premières lignes de la table VIP fusionnée avec la localisation:")
print(head(vip_loc[!is.na(Position)]))
```
```{r}
snp_localisation
```


```{r}
# Utilisation de la table vip_loc qui contient VIP_mean, Chromosome et Position
VIP_THRESHOLD <- 3.0 

# Filtrer les SNP dont le VIP moyen est supérieur au seuil
important_snps <- vip_loc[VIP_mean > VIP_THRESHOLD]

cat(paste("Nombre de SNP conservés après le filtrage VIP >", VIP_THRESHOLD, ":", nrow(important_snps), "\n"))
```

```{r}
important_snps
```



